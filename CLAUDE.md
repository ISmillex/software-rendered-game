# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## Project Overview

A 3D game with a fully software-rendered pipeline in C (C11). No GPU graphics APIs — every pixel is computed on the CPU and written to a flat framebuffer. SDL2 is used only as a dumb display pipe (window creation + texture blit).

## Build Commands

```bash
# Bootstrap the build system (first time only)
cc -o nob nob.c

# Build (default, -O3)
./nob

# Build (debug, with AddressSanitizer + UndefinedBehaviorSanitizer)
./nob debug

# Generate procedural assets (textures, models including sphere meshes)
./nob assets

# Run the game
./build/game
```

The build system is `nob` — a self-rebuilding C build script. If `nob.c` changes, `./nob` recompiles itself before building the game. No Make, CMake, or shell scripts. There are no tests or linters.

**Dependencies:** SDL2 (via homebrew on macOS), pthreads, libm. No third-party C libraries.

## Architecture

Data flows strictly downward through four layers — no layer reaches upward:

```
Application Layer    →  Game loop, Scene, Camera, Input, Physics
Debug/UI Layer       →  Console (Quake-style ~), Game Flags, HUD Overlays (F1/F3/F4)
Rendering Layer      →  Chunks, Strip Distribution, Rasterizers, Glyph Cache
Platform Layer       →  SDL2, pthreads, Arena Allocator, File I/O
```

### Frame Pipeline

1. **Input** — SDL events polled, routed to console or camera+physics.
2. **Player Physics** — Gravity applied to camera `velocity_y`, jump on SPACE when `on_ground`. Fly mode bypasses gravity.
3. **Stone Throwing** — Q key spawns stone bodies with velocity in look direction. Hold for continuous fire (0.15s cooldown).
4. **Player Interact** — Player cylinder tested against all physics bodies; walking into balls/stones kicks them.
5. **Physics Update** — Semi-implicit Euler integration, gravity, floor/wall/AABB collision (sphere-vs-AABB), sphere-vs-sphere collision with velocity reflection and restitution. Bodies come to rest below speed threshold.
6. **Physics Cleanup** — Expired stones (8s lifetime) marked invisible+recyclable, body slots freed.
7. **Scene Update** — Bounce animations, AABB recomputation for moving solids.
8. **Chunk Generation** — Scene objects' triangles transformed through model + VP matrices, emitted as `Chunk` structs. Each chunk = one triangle + rasterizer type (`CHUNK_COLORED` or `CHUNK_TEXTURED`).
9. **Sort** — Chunks sorted front-to-back by depth key (enables early Z rejection).
10. **Strip Distribution** — Screen divided into N vertical strips (N = CPU cores). Each chunk bucketed into overlapping strip(s).
11. **Parallel Render** — N worker threads rasterize their strip buckets. Each thread exclusively owns its x-range — no locks (spatial partitioning).
12. **Overlay Compositing** — HUD/console drawn directly to framebuffer after 3D render.
13. **Present** — `display[]` uploaded to SDL texture.

### Key Design Patterns

- **Chunk = software draw call.** Adding a new visual effect = new chunk type + rasterizer function. This is the "software shader" abstraction.
- **Arena allocator** (`arena.c`): 4MB pre-allocated pool. All per-frame data (chunks, vertex buffers) bump-allocated here. Reset every frame. Zero malloc/free in the hot path.
- **Glyph cache** (`text.c`): All ASCII glyphs pre-rasterized to a bitmap atlas at startup. Text rendering = blitting rectangles. No per-frame font work.
- **Command registry** (`console.c`): Debug console maps command strings to `void (*)(int argc, char **argv)` callbacks. Game flags are exposed as commands (e.g. `fog on`, `fly toggle`).
- **Thread pool** (`strip.c`): Created once at startup, synchronized via pthread barriers. No per-frame thread creation.
- **Physics world** (`physics.c`): Separate `PhysicsBody` array (max 64) with back-pointers to scene objects. Stones are temporary (8s lifetime, recyclable slots); balls are permanent. Collision uses sphere-vs-AABB for walls/cubes and sphere-vs-sphere for body interactions.
- **Scene slot recycling** (`scene.c`): Expired physics objects are marked `recyclable = true`. `scene_add_object()` scans for recyclable slots before appending, preventing the 256-object limit from being exhausted by projectiles.

### Key Constants

- Window: 800x600, ARGB8888
- Frame arena: 4MB
- Max chunks/frame: 16,384
- Max scene objects: 256, max models: 32
- Max physics bodies: 64
- Gravity: 20 units/s², jump impulse: 7 units/s
- Stone: radius 0.08, speed 18 units/s, lifetime 8s, throw cooldown 0.15s
- Ball: radius 0.4, restitution 0.8
- Thread count: auto-detected CPU cores (clamped 1–16)

## Source Layout

All source is in `src/`. Assets are generated by `tools/gen_assets.c`.

- `main.c` — Entry point, initialization sequence, game loop, physics/throw wiring
- `display.c/h` — Framebuffer (`uint32_t display[]`) and z-buffer, SDL texture upload
- `camera.c/h` — Camera state, view/projection matrix computation, gravity, jump, ground detection
- `input.c/h` — SDL event polling into `InputState` struct (edge-triggered keys)
- `scene.c/h` — Scene objects (with recyclable slots), OBJ parser, BMP/PNG texture loader, chunk generation
- `physics.c/h` — Physics world, body management, gravity/collision/bounce simulation, stone spawning, player interaction
- `chunk.c/h` — Chunk types and front-to-back sorting
- `strip.c/h` — Vertical strip distribution, thread pool, barrier sync
- `raster.c/h` — Triangle rasterizers (colored, textured, wireframe)
- `text.c/h` — Glyph cache initialization, text drawing
- `console.c/h` — Debug console, command registry, input routing
- `flags.c/h` — Game flags struct (`g_flags` global, includes `gravity_enabled`), `g_camera` pointer, console command registration
- `hud.c/h` — HUD overlays (flags display, debug info, strip stats, z-buffer viz)
- `arena.c/h` — Frame arena allocator
- `math_utils.h` — Vec2/3/4, Mat4, transforms, projection (header-only, inline)
- `tools/gen_assets.c` — Procedural asset generator (textures: crate, floor, wall, stone, ball; models: floor grid, wall box, sphere_lo, sphere_hi)


